/**
  * @file
  * @author  Pawel Zubrycki <P.Zubrycki@stud.elka.pw.edu.pl>
  * @author  Stanis≈Çaw Janikowski <S.A.Janikowski@stud.elka.pw.edu.pl>
  *
  * @section DESCRIPTION
  *
  * Class implementing FastICA algorithm for independent component analysis (ICA)
  * invented by Aapo Hyvarinen at Helsinki University of Technology.
  *
  **/

#ifndef MBICA_H
#define MBICA_H

#include <armadillo>
#include <boost/parameter.hpp>
#include <iostream>
#include <ctime>

#include "icaseparator.h"
#include "nonlinearities.h"
#include "policies.h"
#include "utils.h"


namespace mbica {

/// default values for epsilon, max iterations and mu
namespace def {
const double EPSILON = 0.0001;
const int MAX_ITERATIONS = 10000;
const double MU = 1.0;
}

BOOST_PARAMETER_NAME(dWh)
BOOST_PARAMETER_NAME(wh)
BOOST_PARAMETER_NAME(guessMatrix)
BOOST_PARAMETER_NAME(epsilon)
BOOST_PARAMETER_NAME(maxIterations)

/**
  * Base class for FastICA.
  *
  * @note It can be only created by FastICA and other derivered classes.
  **/
class FastICA_impl {
protected:

    /**
      *  Constructor
      *
      *  Special constructor required by Boost_Parameter to provide
      *  named parameters in FastICA class.
      *
      * @parameter args Argument provided by Boost_Parameter
      **/
    template <class ArgumentPack>
    FastICA_impl(ArgumentPack const &args)
        : dWh_(args[_dWh | arma::mat()]),
          Wh_(args[_wh | arma::mat()]),
          guess_(args[_guessMatrix | arma::mat()]),
          epsilon_(args[_epsilon | def::EPSILON]),
          maxIterations_(args[_maxIterations | def::MAX_ITERATIONS])
    {
    }

public:
    /**
      * Setter of whitening/dewhitening matrixes.
      *
      * @param Wh Whitening matrix.
      * @param dWh Dewhitening matrix.
      **/
    void setWhiteningMatrix(arma::mat Wh, arma::mat dWh) {
        Wh_ = Wh;
        dWh_ = dWh;
    }

    /// Method to reset whitening and dewhitening matrixes.
    void resetWhiteningMatrix() {
        Wh_.reset();
        dWh_.reset();
    }

    /// Getter of whitening matrix.
    const arma::mat &whiteningMatrix() const {
        return Wh_;
    }

    /// Getter of dewhitening matrix.
    const arma::mat &dewhiteningMatrix() const {
        return dWh_;
    }

    /**
      * Setter of epsilon.
      *
      * Epsilon is a parameter that says how fast iterations will converge.
      * The smaller epsilon is the harder to converge.
      *
      * @param epsilon New value of epsilon.
      **/
    void setEpsilon(double epsilon) {
        epsilon_ = epsilon;
    }

    /// Getter of epsilon value.
    double epsilon() const {
        return epsilon_;
    }

    /// Setter of maximal number of iterations.
    void setMaxIterations(int max) {
        maxIterations_ = max;
    }

    /// Getter of maximal number of iterations.
    int maxIterations() const {
        return maxIterations_;
    }

protected:
    arma::mat dWh_;
    arma::mat Wh_;
    arma::mat guess_;
    double epsilon_;
    int maxIterations_;
};


/**
  * Template class implementing FastICA algorithm for independent component analysis (ICA).
  *
  * @param UsedNonl Nonlinear function to use when calculating.
  * @param Stabilization Whether to use stabilized algorithm.
  **/
template<class UsedNonl = nonlinearities::Pow<3>, class Stabilization = NoStabilization >
class FastICA: public FastICA_impl {
public:
    /**
      * Constructor generated by Boost_Parameter library.
      *
      * It provides named parameter to ease usage of alogrithm.
      * Parameters can be ommited or given in different order than declared.
      *
      * @param _maxIterations Maximal number of iterations. If not provided mbica::def::MAX_ITERATIONS will be set.
      * @param _epsilon Parameter that says how fast iterations will converge. If not provided mbica::def::EPSILON will be set.
      * @param _guessMatrix Initial matrix that can be given to speed up the calculations.
      *        If not provided it will be set to random, orthonormal matrix.
      * @param _dWh Dewhitening matrix. If not provided it will be calculated.
      * @param _wh Whitening matrix. If not provided it will be calculated.
      **/
    BOOST_PARAMETER_CONSTRUCTOR(
            FastICA, (FastICA_impl), mbica::tag
            , (optional
               (maxIterations, *)
               (epsilon, *)
               (guessMatrix, *)
               (dWh, *)
               (wh, *)
            ));

    /**
      * Function that actually calculate FastICA.
      *
      * @param X Matrix with data from which independent components will be calculated.
      * @param nIC Number of independent components to be found.
      *        If set to -1 it will take number of dimensions from data matrix.
      * @param mu Parameter mu. If not provided it's set to mbica::def::MU.
      **/
    ICASeparator operator()(arma::mat X, int nIC = -1, double mu = def::MU) {
        // Calculate whitening/dewhitening matrixes if they were not given.
        if(Wh_.is_empty() || dWh_.is_empty()) {
            arma::mat E;
            arma::vec D;

            X = remmean(X);
            PCA()(X, E, D);
            std::cout<< D << std::endl;
            Whitening()(E ,D, Wh_, dWh_);
            X = Wh_ * X;
        }

        //nIC == -1 means the same size it's now.
        if(nIC < 0 || unsigned(nIC) > X.n_rows) {
            nIC = X.n_rows;
        }

        arma::mat B;
        if (!guess_.is_empty())
            B = Wh_ * guess_;
        else
            B = orth(arma::randu<arma::mat>(X.n_rows, nIC) - 0.5);

        arma::mat B_old = arma::zeros<arma::mat>(X.n_rows, nIC);
        Stabilization stabilize(epsilon_, mu, maxIterations_);

        double k = 1.0 / X.n_cols;
        int i;
        // main loop (with stabilization, but no fine-tunung)
        for(i = 0; i < maxIterations_; ++i) {
            B = B * matSqrt(arma::inv(B.t() * B));

            double minAbsCos = 1.0 - arma::mat(arma::abs(arma::diagvec(B.t() * B_old))).min();
            std::cout << "Step: " << i << ", estimate: " << minAbsCos << std::endl;
            if(minAbsCos < epsilon_)
                break;

            stabilize(i, B, B_old);

            B_old = B;

            arma::mat Y = X.t() * B;
            UsedNonl nl(Y);
            if(mu == 1.0) {
                B = k * (X * nl.G()) - k * (arma::repmat(arma::sum(nl.dG()), X.n_rows, 1)) % B;
                //std::cout << B;
            } else {
                arma::mat Beta = sum(Y % nl.G());
                arma::mat D = diagmat(1.0 / (Beta - sum(nl.dG())));
                B += mu * (B * (Y.t() * nl.G() - diagmat(Beta)) * D);
            }
        }
        std::cout << "Number of iters: " << i << std::endl;
        //std::cout << "We got B = " << B << std::endl;

        return ICASeparator(dWh_ * B, B.t() * Wh_);
    }
};
}

#endif // MBICA_H
